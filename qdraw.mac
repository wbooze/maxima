/************************************************************************
    qdraw.mac is an interface to Maxima's draw2d function which provides
    quicker access to some features of draw2d, with defaults of interest 
    to users from the physical sciences and engineering.
    
    Copyright (C) 2008,2009  Edwin L. Woollett  <woollett@charter.net>       
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU GENERAL PUBLIC LICENSE, Version 2, June 1991,
    as published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details. You should have received a
    copy of the GNU General Public License along with this program.
    If not, see http://www.fsf.org/licensing/.
************************************************************************/   
    

/* file qdraw.mac 
   Edwin L. Woollett
    april,2008 -- jan, 2009
    three functions (in addition to qdraw_usage(),
    pts_syntax(), and vector_use() ),
    are defined in qdraw.mac:
    qdraw1 does all the work for qdraw and produces drlist.
    qdraw calls qdraw1 then passes drlist on to draw2d.
    qdensity only does density plots and is independent of qdraw.
    
    send comments and suggestions for improvement to:
    woollett@charter.net
    
    See tutorial notes:
       Maxima by Example, Ch. 5 for
       a discussion of qdraw() with
       many examples.
    http://www.csulb.edu/~woollett          
    
 */
 
 qdraw_usage() := 
  block([],
  
    print("
 -------------QDRAW SYNTAX------------------------------
 
 Type pts_syntax()$ to see detailed information on
 using qdraw( pts(...),...)  to plot sets of points. 

 All arguments to qdraw(..)  are optional and can be entered in any order.
 
 You can have no more than one xr(..) argument.  Likewise,
  no more than one yr(..), one cut(..), one lw(n) (as an arg of
   qdraw), one nticks(n) and one ipgrid(n).
 
 You can have an arbitrary number of the other args in any order.
 
 The complete set of possible arguments (in alphabetic order) with the
    maximum number and type of arguments follow. In general, arguments
    with names lc,lw,lk,fill,pc,ps,pt,pk,pj,ha,hb,hl,and ht are optional.

    qdraw( arrowhead(x,y,theta-degrees,s,lc(c),lw(n) ),
           circle(x,y,radius,lc(c),lw(n),fill(cc) ),
           contour(expr,x,x1,x2,y,y1,y2,crange(n,min,max),options )
              or contour(expr,x,x1,x2,y,y1,y2, cvals(v1,v2,...), options ),
              contour options are lc(c),lw(n), add( add-options );
                 add-options are grid,xaxis,yaxis,and xyaxes,
           cut(cut-options);
              cut-options are key,grid,xaxis,yaxis,xyaxes,edge,all,
           ellipse(xc,yc,xsma,ysma,th0-deg,dth-deg,lw(n),lc(c),fill(cc) ),
           errorbars(ptlist,dylist,lc(c),lw(n) ),
           ex(exprlist,x,x1,x2),
           ex1(expr,x,x1,x2,lc(c),lw(n),lk(string) ),
           imp(eqnlist,x,xx1,xx2,y,yy1,yy2),
           imp1(eqn,x,x1,x2,y,y1,y2,lc(c),lw(n),lk(string) ),
           ipgrid(n),
           key(bottom) or key(top),
           label( [string1,x1,y1],[string2,x2,y2],...),
           label_align(p-options); p-options are l, r, or c,
           line(x1,y1,x2,y2,lc(c),lw(n),lk(string) ),
           log(log-options); log-options are x, y, or xy,
           lw(n),
           more( any legal draw2d arguments),
           nticks(n),
           para( xofu,yofu,u,u1,u2,lc(c),lw(n),lk(string) ),
           polar( roftheta,theta,th1,th2,lc(c),lw(n),lk(string) );
                       theta, th1, and th2 must be in radians,
           poly([ [x1,y1],[x2,y2],.,[xN,yN] ], lc(c),lw(n),fill(cc) ),
           pts( [ [x1,y1],[x2,y2],.,[xN,yN] ],pc(c),ps(s),pt(t),
                                   pk(string),pj(lw) ),
             type pts_syntax() to see detailed information about plotting
             point sets with pts(...) in qdraw.
           pic( type(t), fname(string), font(string,size)  );
                      font(..) is optional,
           rect( x1,y1,x2,y2, lc(c),lw(n),fill(cc) ),
           vector( [x,y],[dx,dy],lw(n),lc(c),lk(string),
                                   ha(deg),hb(v),hl(v),ht(t) ),
                type vector_use(); to see vector option details,
           xr(xa,xb), 
           yr(ya,yb),            
           );
           
  ...................................................
  QUICK PLOT FEATURES:
  
  For plotting data sets (sets of points) use pts(...)
  inside qdraw. Type pts_syntax()$ to see detailed 
  information about the available features (joining
  points with lines, adding color, etc).
               
  For quick plots of functions, use ex(...) and imp(...). These
  two functions ex(...) and imp(...) use default colors, line widths,
  and simple legend key numbers. The function ex(...) can be used either
  with a single expression, as in ex( u^3,u,-2,2), or with a list
  of expressions as in ex([u,u^2,u^3],u,-2,2).
  
  You can use any other letter instead of 'u', such as 'x', etc.
  
  Like wise the function imp(...), used for the implicit plots of equations,
  can be used for one equation, as in imp(v^3=u^2,u,-2,2,v,-2,2) or for a 
  list of equations as in imp([v=u,v^2=u,v^3=u],u,-2,2,v,-2,2).
  
  You can use any other letters instead of 'u' and 'v', such as 'x' and 'y'.
   
  The top level qdraw argument lw(n) overrides the default line_width
   setting used for ex(...) and imp(...).
  
  You can have multiple ex and imp arguments.
  ....................................................
  
  You recover more control, although limited to either one expression
  or one equation, if you use ex1(...), or imp1(...), using the options
  indicated.
 
===========================================================
the function qdensity(expr,[x,x1,x2,dx],[y,y1,y2,dy], palette(p-options),
                         pic(..) );
       palette(p) and pic(type,filename) are optional;
       palette(blue), palette(gray), palette(color), or palette(n1,n2,n3), 
   can be used to produce a density plot. qdensity is called by itself and
   is not 'wrapped' by qdraw. 
================================================================

   To see the above again, type qdraw()$
     
  "),
  print(" ") )$
  
vector_use() :=  
disp(
"vector([x,y],[dx,dy],ha(thdeg),hb(v),hl(v),ht(t),lw(n),lc(c),lk(string) )
 draws a vector with components [dx,dy] starting at [x,y]. The first two
 list arguments are required, all others are optional and can be entered in
 any order after the first two required arguments.
 The default head angle is 30 deg, change to 45 deg using 
               ha(45) for example.
 The default 'head both' value is f for false, use hb(t) to set
      it to true,and hb(f) to return to false.
 The default 'head length' is 0.5, use hl(0.7) to change to 0.7.
 The default 'head type' is 'nofilled'; use ht(e) for 'empty',
       ht(f) for 'filled',and ht(n) to change back to 'nofilled'.           
 The default line width is 3, use lw(5) to change to 5.
 The default line color is black, use lc(brown) to change to brown.
 The default is no key string. use lk(string) for example to create
     a text string for the key.")$
     
pts_syntax() :=
 block([],
   print("


 ---------------------------------------------------------
   PLOTTING A LIST OF POINTS USING pts(...) inside qdraw(...):
   
  The first argument to pts(..) must be a list of points
  in either the form [ [x1,y1],[x2,y2],...]
  or [ y1,y2,y3,...]. The remaining arguments are all
  optional and can be entered in any order. These 
  optional arguments are pc(color), ps(size),
  pt(type), pj(lw), and pk(string), described below.
 
 ------------------------------------
   qdraw( pts( pointlist ) )  is the simplest invocation.
   
     An example would be 
     
      qdraw( pts( [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ] ) )$
      
        which would plot three points in the default color (black)
        with the default point size (3), with no lines joining the
        points, and take up the whole screen with the limits 
        on the horizontal and vertical canvas set by the numbers in 
        the list.
        
     An even simpler example would be to simply provide a list of
       numbers (taken to be y axis values); in this case qdraw 
       assumes the corresponding x axis values are the 
       integers (1,2,3,...), as in the example
       
         qdraw( pts([-2.2,-0.9,1.5,4.6]))$
            
     The remaining optional arguments can be entered in
     any order. They allow you to control the point size ps(size),
     the point color pc(color), whether or not the points are
     joined ( pj(linewidth) causes the points to be joined with
     lines of the specified width ), the point type pt(type),
     and, finally the string used for the pts(..) plot legend is 
     determined by pk(string).
     
     More details on these options follow:
     
     Point size:  Use ps(1) or ps(2), for example, to get smaller 
       point sizes, useful for plotting a large set of points.
       Use ps(4), ps(5), etc for larger than the default value 3.
     
     Joining Points with Lines:  Use pj(lw), where the linewidth
       integer lw can have values 1, 2, 3, 4,...  The entry
       pj(3) would provide a line thick enough to match the
       default point size (3), lw = 1 is the thinnest line.
       
     Point Color:  Use pc(color), where color is a name of 
     one of the possible colors.
     
       You can see the colors available in the online help
       manual by typing color in the manual index, or draw
       and then scanning for the section on color (or see
       the end of this subsection).
       
       For example, using   
       
         qdraw(
          pts(
           [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ], pc(blue),
                pj(3) ) )$
                
                
         will result in both blue points and joining 
         blue lines. If pc(blue) doesn't work for you, try putting
         double quotes around blue, as in pc(\"blue\").
                  
     Point Type:  Use pt(type), where type is either an
       integer or an available name; see the Help Manual
       index entry under point_type. In contrast to the
       standard draw package default, the qdraw default
       point type is a filled circle (integer 7). You can
       switch to a filled square, for example, by adding
       the option pt(5), as in 
       
         qdraw(
          pts(
           [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ], pc(blue),
                pj(3), pt(5) ) )$
     
       or
         qdraw(
          pts(
           [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ], pc(blue),
                pj(3), pt(filled_square) ) )$
                
        To make the actual points invisible (only the lines
             showing), use point type -1, as is pt(-1).
        
        The full range of point types from the help
        manual is:
        
        none (-1), dot (0), plus (1), multiply (2), 
        asterisk (3), square (4), filled_square (5), 
        circle (6), filled_circle (7), up_triangle (8), 
        filled_up_triangle (9), down_triangle (10), 
        filled_down_triangle (11), diamant (12) 
        and filled_diamant (13). 

     Point Legend String:  Use pk(string), a simple 
        example is,  pk(\"data set 1\"), as an additional
        option to pts(...) (use double quotes, not two
        single quotes, aroung string) .
        
      Thus,
       qdraw(
          pts(
           [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ], pc(blue),
                pj(3),pk(\"data set 1\") ) )$
                
       will write the string supplied at the top right
       of the screen (the default). If you want to move
       that legend to the bottom right of the screen,
       use key(bottom) as a separate option to qdraw(..),
         (ie., not as an option to pts(..) ).
         
       For example:
       
         qdraw(  key(bottom),
          pts(
           [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ], pc(blue),
                pj(3),pk(\"data set 1\") ) )$
                
        will place the legend at the bottom right.
        
      Adding Space Around the Points:  Use the horizontal range 
         control xr(..) and/or the vertical range control
         yr(..) options to qdraw(...), as in
         
         qdraw(  key(bottom), xr(-2,5),
                yr(-3,5),
          pts(
           [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ], pc(blue),
                pj(3),pk(\"data set 1\") ) )$
                
      Combining Point Set with Curves:  If you want to
       add one or more curves (based on explicit functions)
       it is easiest to use ex(..) as an option to qdraw(..).
       
       (%i19) g1:x^2$
       (%i20) g2:x^3$
       (%i21) qdraw(  key(bottom), xr(-2,5),
                yr(-3,5),ex([g1,g2],x,-1,1),
          pts(
           [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ], pc(blue),
                pj(3),pk(\"data set 1\") ) )$
                
       Alternatively, you get more control over the
         separate curves if you use ex1(...) for each
         function or expression, as in
         
      (%i25) qdraw(  key(bottom), xr(-2,5),
                yr(-3,5), ex1(g1,x,-2,2,lc(green),
                     lw(4),lk(\"x^2\") ),
                ex1(g2,x,-1,1,lc(dark-cyan),lw(4),
                    lk(\"x^3\") ),
          pts(
           [ [-1.2,-2.4],[0,0.9],[2.5,4.4] ], pc(blue),
                pj(3),pk(\"data set 1\") ) )$
         
         
       The syntax for ex(..) and ex1(..) is
       ex(exprlist,x,x1,x2),
       
       ex1(expr,x,x1,x2,lc(c),lw(n),lk(string) ),  
       
        in which the args lc(c) (line color), lw(n)
        (line width), and lk(string) (key legend 
        for curves) are optional args for ex1(..).
                
      Complete Set of Available Color Names (from the help
        manual - (Note that compound names are hyphenated):
        
         white, black, gray0, grey0, gray10, 
         grey10, gray20, grey20, gray30, grey30, 
         gray40, grey40, gray50, grey50, gray60, 
         grey60, gray70, grey70, gray80, grey80, 
         gray90, grey90, gray100, grey100, gray, 
         grey, light-gray, light-grey, dark-gray, 
         dark-grey, red, light-red, dark-red, 
         yellow, light-yellow, dark-yellow, green, 
         light-green, dark-green, spring-green, 
         forest-green, sea-green, blue, light-blue, 
         dark-blue, midnight-blue, navy, medium-blue, 
         royalblue, skyblue, cyan, light-cyan, 
         dark-cyan, magenta, light-magenta, dark-magenta, 
         turquoise, light-turquoise, dark-turquoise, 
         pink, light-pink, dark-pink, coral, 
         light-coral, orange-red, salmon, light-salmon, 
         dark-salmon, aquamarine, khaki, dark-khaki, 
         goldenrod, light-goldenrod, dark-goldenrod, 
         gold, beige, brown, orange, dark-orange, 
         violet, dark-violet, plum and purple. 
    "),
    print(" ") )$


disp(" qdraw(...), qdensity(...), 
     general syntax: type qdraw()$
     plotting data sets: type pts_syntax()$ ")$



/*********************************** working version qdraw1  */

qdraw1([qda]) :=
   block([ anerr,arg,ax,ay,bx,by,cc,cdv,clist,cnum,coldef,ct,ctop,ctargs,cval, drlist,dy,dyl,
     eex,elist,eqe,errblw,fnamelst,fnamestr,fntsize,fntstr, hlim,hvlim,
     ipgriddef,iq,jq,kk,klist,labadef,le,lendr,ll,lp,lqda,lwa,lwdef,lwval,mkedge,mkgrid,
     labellist,mkkey,mkxaxis,mkxyaxis,mkyaxis,morelist,msg,nn,nargs,ndef,nlabel,nlw,npic,
     nps,nticksdef,nxr,nyr,phi,piclist,pictype,pl,pl1,pr,prlist,pstr,ptl, ptsdef,pttdef,ptsl,ptslist,
     qt,ratprint,rl,rnglist,sa, setnlw,stringdisp,targs,
     th, tlist,qtop,tp,tt,ttargs,ttop,tval,ulim,xx, x1rr,x2rr,yy, y1rr,y2rr ],
       local(goodargs, eqncheck,doerr,qval,setnpc,setnlw,setnlk,setnfill,setoptions,inlistp),

       stringdisp:true, 
       ratprint:false,
/*       display2d:false, */

       /* default value of curve linewidth and color */   
       
       lwdef : 3,       
       lwval: lwdef,
       coldef : black,
       
       /* default point size and type */
       ptsdef : 3,
       pttdef : 7,
       
       /* default label alignment */
       labadef : left,

       
       /* default value of nticks for qdraw
          can be changed to 200 for all inputs by including
          qdraw( ..., nticks(200), ...) for example   */
       nticksdef : 100,
       ipgriddef : 10,
          
     /* ndef set to true each time a separate ex or imp arg found
        */
        ndef : false,
        
        /* npic set to true each time pic(...) is found  */
        npic : false,
        
        /* nlabel set to true each time label(...) is found */
        nlabel : false,
                                  
       morelist : [],
       piclist : [],
       ptslist : [],
       labellist : [],
       
  /* drlist will be the ultimate list of arguments sent to draw2d */
     
     drlist : [], 
     
     /* rnglist is a temporary parking lot for x and y range items */
     rnglist : [],
     /* nxr = number of xr() arguments found */
     nxr : 0,
     /* nyr = number of yr() arguments found  */
     nyr : 0, 
       
       
       /* by default, include key, grid, all axes */
       mkkey : true,
       mkgrid : true,
       mkxyaxes : true,
       mkedge : true,
       mkxaxis : true,
       mkyaxis : true,
/*
qdraw( arrowhead(..), circle(..),contour(), cut(..),ellipse(..), errorbars(...),
     ex(..), ex1(..), imp(..),imp1(..),ipgrid(), key(..),label(...),label_align(..),
      line(..), lw(n), more(..),nticks(..), pic(..), para(...),
     polar(..), poly(..), pts(..), rect(..),vector(..), xr(..), yr(..) )
	
*/

/* function goodargs(arglist, msg, goodarglist) returns true
		   if all args in arglist are not atoms and if op(item)  matches an
		    arg in goodarglist, otherwise issues a return with the error
		     message msg and returns false */
		     
 goodargs(arglist,msg,goodarglist) :=
		   block( [aa,ii,jj ,nchk], 
		   
		     		     
		    for ii thru length(arglist) do ( 
		       aa : arglist[ii],  
		       
		       if atom(aa) then (  
		          nchk : false,
		          print(" arg ",aa," must itself have args "), 
		          return( doerr(msg) )
		        ),

		        nchk : false,
		        
		        
		        for jj thru length(goodarglist) do (  
		          if op(aa) = goodarglist[jj] then (
		            nchk : true,
		            return()
		           )
		          /* end jj do loop */
		         ), 
		          
		        /* if aa not found in goodarglist, we are
		            left with nchk equal to false */  
		       if not nchk then (  
		           print(" arg ",aa," problem"),
		            return(doerr(msg)) 
		            )
		         /* return for next ii */
		     ),
		      
		     return(nchk)
		     
		   ),		   

       
       /* syntax errors change anerr to true */
       
       anerr : false, 
       
       /* default color selection list for ex(..) and imp(...)  */
       
      cc: [blue,red,turquoise,brown,magenta,green,black],
            
      /* eqncheck returns true if item head is "=", else returns false */    
      
      eqncheck(eqe) := (
         if atom(eqe) then false
           else if op(eqe) = "=" then true else false ),
          
       /*  write standard form error message  */   
          
       doerr(msg) := (anerr:true,print("...syntax error"),print(msg),false),
                    
                               
      /* gets elements 1 thru 7 of color list for arbitrary n  */                 
          
     qval(nn) := (if mod(nn,7)=0 then 7 else mod(nn,7) ),
              
     setnpc(ll) := ( 
        if length(ll)=1 then (
                 ptsl :  cons(color=ll[1], ptsl ),
                 ptsl : append( ptsl, [color = coldef] )
                 )                        
                  else return( doerr("use lc(red) for example " ) )
               ), 

     setnlw(ll) := ( 
        if length(ll)=1 then (
                 ptsl :  cons(line_width= ll[1], ptsl ),
                 ptsl : append( ptsl, [line_width = lwdef] )
                 )                       
                  else return( doerr("use lw(5) for example " ) )
               ),
               
       setnlk(ll) := ( 
        if length(ll)=1 then (
                 ptsl : cons(key = ll[1], ptsl),
                 ptsl : append(ptsl, [ key = "" ] )                  
                 )                       
                  else return( doerr(" use lk(\"case 1\") for example " ) )
               ),             
               
     
     setnfill(ll) := ( 
                     if length(ll)=1 then (
                        ptsl :  cons(fill_color = ll[1], ptsl),
                        ptsl :  cons(transparent = false, ptsl),
                        ptsl : append(ptsl, [ transparent = true])
                         )     
                      else return( doerr("use fill(blue) for example" ) )  
                    ),      

     /* setoptions(list) is called by line, ex1,imp1 pts,circle,ellipse,poly,rect     */
     
     setoptions(prlist) := block( [jj,tt,ttop,ttargs ],                    
                                 
          for jj thru length(prlist) do (
            tt : prlist[jj],     
            ttop : op(tt),
            ttargs : args(tt),
            if ttop = lc then setnpc(ttargs),
            if ttop = lw then setnlw(ttargs),
            if ttop = lk then setnlk(ttargs),
            if ttop = fill then setnfill(ttargs)            
          )   /* end do loop  */
      ),         
      
      /* inlistp(a,ll) returns true if a is found in list ll
         otherwise returns false 
         */
         
     inlistp(aaa,lll) := block([fff,xxx], 
              fff : false,
              for xxx in lll do if xxx = aaa then fff:true,
            
            fff ),
     
/********  start of main program  ****************/     
      
    /*  qda is the list of arguments given to qdraw */   
 
     /* lqda is the number of arguments to qdraw */
     
     lqda : length(qda), 
     
     /* refer to syntax usage function  if no arguments */
     
     if lqda = 0 then ( qdraw_usage(),return(false) ),

/* debug 
     display(qda),
*/     
     /* check for all valid args to qdraw */
     
     if not goodargs(qda,"qdraw args:arrowhead(), circle(), contour(), cut(), ellipse(), errorbars(), ex(), ex1(), imp(), imp1(),ipgrid(),key(),label(),label_align(), line(), log(), lw(n), more(),nticks(),para(),pic(),polar(), poly(), pts(), rect(),vector(), xr(), yr() ",
	      [arrowhead,circle,contour,cut,ellipse,errorbars,pic,ex,ex1,imp,imp1,ipgrid,key,label,
	          label_align,line,log,lw,more,nticks,para,pic,polar,poly,pts,rect,vector,xr,yr]  ) 
	      then return(false),
	      

     /************************* scan 1: set defaults with lw(n),nticks(n),
                                        log(a),   cut(...), xrange, yrange options  */
          
     for iq thru lqda do (
     
     if anerr  then return( ),
   
     /* qt is one argument to qdraw : we have already checked that the args to
         qdraw are not atoms and op(arg) matches an allowed arg  */
     
        qt : qda[iq],
                      
                                                         
        /* qtop is head of qt */
        /* targs is list of args of qt */
        
        qtop : op(qt),
                           
        targs : args(qt),
        
         /****************************  case  lw   ****************/
         /* lw(n) arg to qdraw only affects the drawing of the 
             arguments of ex(...) and imp(...) which use lwval  */
         
          if qtop = lw then ( 
          
             /* check that lw has only one argument */
             if length( targs ) # 1 then 
               return( doerr("lw  must have one and only one argument" ) ),
               
              lwa : targs[1], 
              
              if integerp(lwa) then lwval : lwa
                else  return( doerr("lw arg must be a literal integer like 2" ) )
             /*  end case lw  */    
           ),
           
           /********* case log *********************************/
           
           if qtop = log then (  
              /* check that log has only one argument */
             if length( targs ) # 1 then 
               return( doerr(" use log(a) where a is x, y, or xy " ) ),
               
             pl : targs[1],
             
             if not inlistp(pl, [x,y,xy] ) then
                return(doerr(" use log(a) where a is x, y, or xy ")),               
                
             if pl = x then loglist : [logx = true]
               else if pl = y then loglist : [logy = true]
               else if pl = xy then loglist : [logx = true, logy = true]
               else
                 return( doerr(" use log(a) where a is x, y, or xy" ) ),
                 
              drlist : append(drlist, loglist)     
              
              /* end case log */
           ),
           
           
           /*********  case nticks  **********************************/
           /*  current default is 100  */
           
           if qtop = nticks then ( 
          
             /* check that nticks has only one argument */
             if length( targs ) # 1 then 
               return( doerr("nticks ex: nticks(200) " ) ),
               
              nticksdef : targs[1]
                            
             /*  end case nticks  */    
           ),
           
         /*********  case ipgrid  **********************************/
         
         /* this over-rides the default parameter used for the
            draw2d arg:  ip_grid_in = [n,n]   
            draw2d's default value for n is 5 with some jaggies
            as a result. this program uses the default value of
            10, which reduces jaggies but requires more time for
            the plot to be created. Especially for the
            contour function, you may need to increase this
            parameter to 15 or 20 to get smooth curves 
            */
           
           if qtop = ipgrid then ( 
          
             /* check that ipgrid has only one argument */
             if length( targs ) # 1 then 
               return( doerr("ipgrid ex: ipgrid(15) " ) ),
               
              ipgriddef : targs[1]
                            
             /*  end case ipgrid  */    
           ),
           
           
           /****************************  case cut   ****************/
           
           /*  cut(edge) removes the grid as well as the border
                axes and tick marks  
              cut(all) removes key, grid, xyaxes, boder axes, tick marks 
              cut(grid) only removes grid, 
              cut(key) removes key
              cut(xyaxes) removes both x and y axes
              cut(yaxis) removes only y axis
              cut(xaxis) removes only x axis
              cut(edge) removes grid, border axes and tics
              example: cut(key,grid,yaxis)
              */
         
         if qtop = cut then (
           /* since all valid args to cut are atoms, check syntax here  */
         
           eex : targs,
           le : length(eex),
           for jq  thru le do (
           
             pl : eex[jq],
             
             if not inlistp(pl,[all,edge,grid,key,xaxis,xyaxes,yaxis]  ) then
                return( doerr( "cut: valid args: all,key,grid,xyaxes,xaxis,yaxis,edge ")),
                
             if pl = all then (
               mkkey : false,
               mkgrid : false,
               mkxyaxes : false,
               mkedge : false 
               ),
             if pl = key then mkkey : false,
             if pl = grid then mkgrid : false ,
             if pl = xyaxes then mkxyaxes : false,
             if pl = xaxis then mkxaxis : false,
             if pl = yaxis then mkyaxis : false,
             if pl = edge then mkedge : false
            /* end do loop */ 
           )  
         
             /*  end case cut  */    
           ),
           
            
         /********************** case xr  ************************/ 
               
         if qtop = xr  then ( 
         
           /* check that only one xr item is provided to qdraw */
           
           nxr : nxr + 1, 
           
           if nxr = 2 then
                  return( doerr("only one xr(xa,xb) item allowed in qdraw" ) ),
                                      
           if length( targs ) # 2 then 
               return( doerr("xr must be of form xr(xa, xb)" ) ),
                                                                                                         
           x1rr : float( targs[1] ),
           
            if not numberp(x1rr) then
            return( doerr("xr(x1,x2): x1 is not a number" ) ),   
            
           x2rr : float( targs[2] ), 
           
            if not numberp(x2rr) then
            return( doerr("xr(x1,x2): x2 is not a number" ) ),   
            
           tval : xrange =  [x1rr,x2rr] ,
           
           
           /* this puts xrange item first in case list
               already contains yrange item  */
           
           rnglist : cons(tval, rnglist) 
           
            /* end case xr */                   
          ), 
               
         /************************  case yr  **************/   
           
               
         if qtop = yr then ( 
             
             /* check that only one yr item is provided */
           nyr : nyr + 1, 
           
           if nyr = 2 then 
               return( doerr("only one yr(ya,yb) item allowed in qdraw" ) ),
                                      
           if length( targs ) # 2 then 
               return( doerr("yr must be of form yr(ya, yb)" ) ),
                                      
           y1rr : float( targs[1] ), 
           
           if not numberp(y1rr) then
            return( doerr("yr(y1,y2): y1 is not a number" ) ),
           
           y2rr : float( targs[2] ), 
           
           if not numberp(y2rr) then
            return( doerr("yr(y1,y2): y2 is not a number" ) ),
            
           tval : yrange =  [y1rr, y2rr] , 
           
                     
           /* this puts yrange item last in case list
                already contains xrange item  */
                
           rnglist : append(rnglist,[tval] ) 
            /*  end case  yr  */ 
           ) 
             
              /* end do loop scan 1 */
                   
       ),
       if anerr then return(),
       
           /* put range into drlist as first contents if xr and or yr found
           
           at end  */
       
        
       
       /************** scan 2: look for ex and imp options 
                we have already looked at all qdraw args and checked that
                none are atoms   */

       for iq thru lqda do (    
       
       if anerr  then return( ),
        
     /* qt is one argument to qdraw */
     
        qt : qda[iq],
                                          
        /* qtop is head of qt */
        /* targs is list of args of qt */
        
        qtop : op(qt),
        targs : args(qt),
                               
        /*******************  case ex  *****************/
        
        if qtop = ex  then (
        
            ndef : true,
                          
           if length(targs) # 4 then             
             return( doerr("ex() should have exactly four arguments" ) ),
                
                                        
        /*  targs[1] is either an expression list or single expression */
          eex : targs[1],
          
          /* if not a list, make it a list */
          if not listp(eex) then eex : [eex], 
          
          /*  the rest of targs should be [x,x1,x2 ] */
          
            /* first make sure numerical arguments of hlim
               are converted to floating point numbers, especially
               things like [x,-%pi/2,%pi/2]    */
               
          hlim : float( rest(targs,1) ), 

           /* check first element of hlim is not a number */
           
           if numberp(hlim[1]) then
            return( doerr("ex: hlim=[x,x1,x2]: x is a number" ) ), 
          
                          
           /* check last two elements of hlim are numbers */

          if not numberp(hlim[2]) then
            return( doerr("ex: hlim=[x,x1,x2]: x1 is not a number" ) ),
           
          if not numberp(hlim[3]) then
            return( doerr("ex: hlim=[x,x1,x2]: x2 is not a number" ) ),
             
                                
            /* how many expressions in list of expressions passed to ex() ? */      
            le : length(eex), 
            
            /* look at each expression separately */
            
                                                                     
           for jq thru le do (
               
               /* if "expression" is equation , an error */
               if eqncheck(eex[jq]) then
                     return( doerr("you have an equation in ex() " ) ),
                                                                       
             /* make a list out of expression and hlim  */        
               tlist : cons(eex[jq],hlim),
               
               /* wrap "explicit" around list items */
               tval : apply( 'explicit, tlist ), 
               
               /* add this explicit(...) item to draw2d list */
               drlist : append(drlist, [tval] )
                 /* end jq do loop */
                )
                /*  end case ex  */
            ),
           
                     
        /*******  case  imp **********     similar in structure to ex */      
        
        if qtop = imp  then ( 
        
               ndef : true,
               
             /* imp must have exactly seven arguments */
                        
             if length(targs) # 7 then
                   return( doerr("imp() should have exactly seven arguments" ) ),
                             
            eex : targs[1],
            
            if not listp(eex) then eex : [eex], 
            
            /* but first make sure limits like %pi/2 get
                converted to floats  */
            
            hvlim : float( rest(targs,1) ), 
            
            
            /* check elements of hvlim  */
           
           if numberp(hvlim[1]) then
            return( doerr("imp: hvlim=[x,x1,x2,y,y1,y2]: x is a number" ) ), 
                                                  
           if not numberp(hvlim[2]) then
             return( doerr("imp: hvlim=[x,x1,x2,y,y1,y2]: x1 is not a number" ) ),   
            
           if not numberp(hvlim[3]) then
              return( doerr("imp: hvlim=[x,x1,x2,y,y1,y2]: x2 is not a number" ) ),   
            
           if numberp(hvlim[4]) then
             return( doerr("imp: hvlim=[x,x1,x2,y,y1,y2]: y is a number" ) ), 
            
           if not numberp(hvlim[5]) then
             return( doerr("imp: hvlim=[x,x1,x2,y,y1,y2]: y1 is not a number" ) ),   
            
           if not numberp(hvlim[6]) then
             return( doerr("imp: hvlim=[x,x1,x2,y,y1,y2]: y2 is not a number" ) ),   
                                              
            le : length(eex), 
            
            /* look at each equation  */
                        
            for jq thru le do ( 
            
               if not eqncheck(eex[jq]) then 
                   return( doerr("one imp() arg is not an equation " ) ), 
                                           
               tlist : cons(eex[jq], hvlim ), 
               tval : apply( 'implicit, tlist ), 
               drlist : append(drlist, [tval] )
               /* end jq do loop  */
               )
               /*  end case imp  */
          )
          
          
        ),   /* end do loop scan 2  */
        
        if anerr then return(),
        
                  
          /* construct drlist with default colors for ex and
                        imp items if we have any */
                        
         if ndef then (                        
          
             /* add default colors and simple numbers for key to plot items  */
             /* key defaults to empty string for explicit and implicit */
           
                         
             lendr : length(drlist),
       
              clist : makelist(color=cc[ qval(kk) ],kk,1,lendr ), 
       
              if mkkey then (
                 klist : makelist( key = string(kk), kk, 1, lendr),
                 drlist : flatten(makelist([clist[kk],klist[kk],drlist[kk] ],kk,1,lendr ) )
                )               
                else drlist: join( clist, drlist ),
           
                /*  use my default lwval = lwdef unless overridden 
                        with top level lw(n) arg   */
       
                 drlist : cons( line_width=lwval, drlist ), 
           
                /* return to defaults after plotting ex and imp stuff */
           
              /* drlist : append(drlist, [color = coldef, line_width = lwdef, transparent = true,
                                          point_size = ptsdef,point_type = pttdef,
                                          label_alignment=labadef ] ),  */
                                          
                 drlist : append(drlist,[ color = coldef ] )                         
           
              /*  if mkkey then drlist : append(drlist,[key = ""])  */
            ),
            
            if mkkey then drlist : append(drlist,[key = ""]),
           
            drlist : append(drlist, [ line_width = lwdef, transparent = true,
                          point_size = ptsdef,point_type = pttdef,label_alignment=labadef,
                          head_type=nofilled, head_angle=30,head_length= 0.5 ] ),
           

        /******************************************/
        /*** scan 3  look for remaining allowed args to qdraw */

       for iq thru lqda do (    

        if anerr  then return( ),
        
     /* qt is one argument to qdraw */
     
        qt : qda[iq],
                                          
        /* qtop is head of qt */
        /* targs is list of args of qt */
        
        qtop : op(qt),
        targs : args(qt),  
        
        /**************   case key    ***********************/
        
        if qtop = key then ( 
                       

           if length(targs) > 1 then 
                  return( doerr("use key(bottom) or key(top) ")),
            
            tt : targs[1],
            
            if tt = bottom then
              ptslist : append( ptslist, [ user_preamble="set key bottom" ] )
              
            else if tt = top then 
              ptslist : append( ptslist, [ user_preamble="set key top" ] )
              
            else   
                 return( doerr("use key(bottom) or key(top) "))
                 
          
        ),
        
        /************* case label **********************/
        /* syntax:
           label( [s1,x1,y1],[s2,x2,y2],... ) 
           example:
             label( ["max",1,1],["min",-1,-1] )
           
           you can use label_align(p) to override the default left setting
        */
        
        if qtop = label then ( 
        
           nlabel : true,
			
           labellist : append(labellist, [ apply( 'label, targs ) ] )               
        
        
          /* end case label  */
         ),
         
         /************ case label_align  ***************/
         
         /* syntax:
            label_align(p) where p is l,r,c
            left is the default until this is called, henceforth,
            whatever value of p is used remains the default until
            this is called again. the new setting is placed in the left
            end of the labellist at the time label_align is called
            */
            
         if qtop = label_align then (  
             
            if length(targs) > 1 then
               return(doerr(" use label_align(p) where p is l, r, or c ") ),
               
             pl : targs[1],
             
             if not inlistp(pl, [l,r,c] ) then
                return(doerr(" use label_align(p) where p is l, r, or c ")),
                
             if pl = l then labadef : left,
             if pl = r then  labadef : right,
             if pl = c then labadef : center,
             
             labellist : append(labellist,[ label_alignment = labadef ] )  
             /*  end case label_align  */            
          
          ),   
        
        /************** case ex1   ***********************/
        
        /* syntax:
             ex1( expr, x, x1, x2, lc(c), lw(n) ,lk(string)  )
            example:
            ex1( u^3,u,-2,2,lc(blue), lw(5),lk("case 1") ) 
             */
             
        if qtop = ex1 then ( 
                  
         /* the first four args are required for passing
             to draw2d's explicit(..)
              */
           
          nargs : length(targs), 
          
          if nargs < 4 then (print("ex1 syntax: ex1(expr,x,x1,x2,lc(c),lw(n),lk(string) ) "),
                  print("first four args required"),
               return( doerr("only lc(c), lw(n), and lk(string) options can be included"))
               ),
          if nargs > 7 then return( doerr("ex1: only lc(c), lw(n), and lk(string) options allowed ")),
          /* elist hold four args for explicit */
          
          elist : rest(targs,-(nargs-4) ),
          
          /* the first arg of elist should not be a list  */
          
          if listp(elist[1]) then
               return( doerr("ex1: first arg should not be a list")),
          
          /*  the last three args of elist should be [var,var1,var2 ] */
          
            /* first make sure numerical arguments of hlim
               are converted to floating point numbers, especially
               things like [x,-%pi/2,%pi/2]    */
               
          hlim : float( rest(elist,1) ), 
          
           /* check first element of hlim is not a number */
           
           if numberp(hlim[1]) then
            return( doerr("ex1: hlim=[x,x1,x2]: x is a number" ) ), 
          
                          
           /* check last two elements of hlim are numbers */

          if not numberp(hlim[2]) then
            return( doerr("ex1: hlim=[x,x1,x2]: x1 is not a number" ) ),
           
          if not numberp(hlim[3]) then
            return( doerr("ex1: hlim=[x,x1,x2]: x2 is not a number" ) ),
             
          
         
          /* the first four arguments pass to draw2d's explicit function
              as explicit(expr, x, x1, x2)  */
          
          ptsl : [apply( 'explicit, elist ) ],  
         
         
          /* pr is a list of zero, one, two, or three options  */
          
          pr : rest(targs,4),
          lp : length(pr), 

          if lp > 0 then (             
                                           
             if not goodargs(pr,"ex1 options: lc(color), lw(n), lk(string) ",[lc,lw,lk] )
                  then  return() ,
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)
             ),
   /* merge ptsl with ptslist  */
                
          ptslist : append( ptslist, ptsl )
   
             /* end case ex1  */
        ),
        
        /************* case imp1 ****************************/
        
   /* syntax:
             imp1( equation, x, x1, x2,y,y1,y2, lc(c), lw(n) ,lk(string)  )
            example:
            imp1(v^2= u^3,u,-2,2,v,-3,3, lc(blue), lw(5),lk("case 1") ) 
             */
             
        if qtop = imp1 then ( 
                  
         /* the first seven args are required for passing
             to draw2d's implicit(..)
              */

         nargs : length(targs), 
         
         if nargs < 7 then
                   return( doerr("imp1 syntax: imp1(eqn,x,x1,x2,y,y1,y2,options)" ) ),

          if nargs > 10 then return( doerr("imp1: only lc(c), lw(n), and lk(string) options allowed ")),
          
          /* elist hold seven args for implicit */
          
          elist : rest(targs,-(nargs-7) ), 
          
          /* the first arg of elist should not be a list  */
          
          if listp(elist[1]) then
               return( doerr("imp1: first arg should not be a list")),
               
          /* the first arg of elist should be an equation */          
          
          if not eqncheck(elist[1]) then 
                   return( doerr("imp1: first arg should be an equation " ) ),           
          
          /*  the last six args of elist should be [x,x1,x2,y,y1,y2 ] */
          
            /* first make sure numerical arguments of hlim
               are converted to floating point numbers, especially
               things like [x,-%pi/2,%pi/2]    */
               
          hlim : float( rest(elist,1) ), 
                      
           if numberp(hlim[1]) then
            return( doerr("imp1(eqn,x,x1,x2,y,y1,y2,options): x must be a symbol" ) ), 

          if not numberp(hlim[2]) then
            return( doerr("imp1(eqn,x,x1,x2,y,y1,y2,options): x1 must be a number" ) ),
           
          if not numberp(hlim[3]) then
            return( doerr("imp1(eqn,x,x1,x2,y,y1,y2,options): x2 must be a number" ) ),
             
          if numberp(hlim[4]) then
            return( doerr("imp1(eqn,x,x1,x2,y,y1,y2,options): y must be a symbol" ) ), 
            
          if not numberp(hlim[5]) then
            return( doerr("imp1(eqn,x,x1,x2,y,y1,y2,options): y1 must be a number" ) ),
           
          if not numberp(hlim[6]) then
            return( doerr("imp1(eqn,x,x1,x2,y,y1,y2,options): y2 must be a number" ) ),
         
          /* the first seven arguments pass to draw2d's implicit function
              */
          
          ptsl : [ apply('implicit, elist) ], 
         
         
          /* pr is a list of zero, one, two, or three options  */
          
          pr : rest(targs,7),
          lp : length(pr), 

          if lp > 0 then (             
                                           
             if not goodargs(pr,"imp1 options: lc(color), lw(n), lk(string) ",[lc,lw,lk] )
                  then  return() ,
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)
             ),
   /* merge ptsl with ptslist  */
                
          ptslist : append( ptslist, ptsl )
   
             /* end case imp1  */
        ),        
        
        /*************** case contour ********************/
        
        /* syntax
         contour(expr,x,x1,x2,y,y1,y2,crange(n,min,max),options )
            or contour(expr,x,x1,x2,y,y1,y2, cvals(v1,v2,...), options  )
          where options are lc(color), lw(n), and add(options = elements from 
            the set [grid,xaxis,yaxis,xyaxes] )  

        */
            
     if qtop = contour then ( 
          
          print("   contour working... "),
                  
         /* the first seven args will be used with a cval implied by the
            last argument to provide args to draw2d's implicit(..)
              */

         nargs : length(targs), 
         
         if nargs < 8 then
                   return( doerr("contour syntax: contour(expr,x,x1,x2,y,y1,y2,cvals(v1,v2,...),options )
            or contour(expr,x,x1,x2,y,y1,y2, crange(n,min,max),options )" ) ),

          
          /* elist is a list of the first seven args  */
          elist : makelist( targs[jj],jj,1,7 ), 
          
          /* the first arg of elist should not be a list  */
          
          if listp(elist[1]) then
               return( doerr("contour: first arg should be an expression depending on
                    two variables ")),
               
          /* the first arg of elist should not be an equation */          
          
          if eqncheck(elist[1]) then 
                   return( doerr("contour: first arg should be an expression " ) ),           
          
          /*  the last six args of elist should be hlim =  [x,x1,x2,y,y1,y2 ] */
          
            /* first make sure numerical arguments of hlim
               are converted to floating point numbers, especially
               things like [x,-%pi/2,%pi/2]    */
               
          hlim : float( rest(elist,1) ), 
                      
           if numberp(hlim[1]) then
            return( doerr("contour(expr,x,x1,x2,y,y1,y2,options): x must be a symbol" ) ), 

          if not numberp(hlim[2]) then
            return( doerr("contour(expr,x,x1,x2,y,y1,y2,options): x1 must be a number" ) ),
           
          if not numberp(hlim[3]) then
            return( doerr("contour(expr,x,x1,x2,y,y1,y2,options): x2 must be a number" ) ),
             
          if numberp(hlim[4]) then
            return( doerr("contour(expr,x,x1,x2,y,y1,y2,options): y must be a symbol" ) ), 
            
          if not numberp(hlim[5]) then
            return( doerr("contour(expr,x,x1,x2,y,y1,y2,options): y1 must be a number" ) ),
           
          if not numberp(hlim[6]) then
            return( doerr("contour(expr,x,x1,x2,y,y1,y2,options): y2 must be a number" ) ),
         
          /* the first seven arguments pass to draw2d's implicit function
              */
          
          /* pl is eighth arg and is either cvals(v1,v2,...) or crange(n,min,max)  */
          
          pl : targs[8], 
          
          if atom(pl) then
             return( doerr("contour eighth arg: cvals(v1,v2,...) or crange(n,min,max)" ) ),  
          
         /* construct ptsl list for the two cases possible  with the eighth arg */
         
         ptsl : [],
         
         if op(pl) = cvals then (  
           tt : args(pl), 
           for cval in tt do (
              ptl : hlim,
              ptl : cons( first(elist)=cval, ptl),
              ptsl : append(ptsl,[apply('implicit,ptl) ] )
           )
         )
         
         else if op(pl) = crange then (  
            tt : args(pl),
           if length(tt) # 3 then
             return( doerr("contour last arg: cvals(v1,...) or crange(n,min,max)" ) ),  
           cnum : first(tt),
           
           if not integerp(cnum) then
             return( doerr("crange(n,min,max): n must be literal integer, like 10" ) ),  
           if cnum = 0 then
                     return( doerr("crange(n,min,max): n cannot be zero " ) ), 
           if not numberp(tt[2]) then
                     return( doerr("crange(n,min,max): min must be a number" ) ), 
           if not numberp(tt[3]) then
                     return( doerr("crange(n,min,max): max must be a number" ) ), 
           if tt[3] < tt[2] then
                return( doerr("crange(n,min,max): max must be greater than min " ) ), 
           cdv : float( abs((tt[3] - tt[2])/cnum) ) , 
           for kk thru cnum do (
             ptl: hlim,
             cval : tt[2] + (kk - 1)*cdv,
             ptl : cons( first(elist)=cval, ptl),
             ptsl : append(ptsl,[apply('implicit,ptl) ] )             
            )
         )
         
         else return( doerr("contour last arg: cvals(v1,...) or crange(n,min,max)" ) ),  
         
         
         /* contour default: no grid and no xyaxes can be overridden
            by add(grid, xyaxes) for example */
            
         mkgrid : false,   
         mkxaxis : false,   
         mkyaxis : false,
         
         
         /* pr is a list of zero, one, two, or three options  */
          
          pr : rest(targs,8),
          lp : length(pr), 
          nlw : false,

          if lp > 0 then ( 
                                           
             if not goodargs(pr,"contour options: lc(color), lw(n), add(options) ",[lc,lw,add] )
                  then  return() ,
                  
             /* we know args are not atoms and are legal
                 because we are using def line width = 1 for contour, we need
                 to call setnlw and setnpc here */     

             for kk thru lp do ( 
               ct : pr[kk], 
               ctop : op(ct),
               ctargs : args(ct),
               if ctop = lc then setnpc(ctargs),
               if ctop = lw then 
                   if length(ctargs)=1 then ( 
                     nlw : true,
                     ptsl :  cons(line_width= ctargs[1], ptsl ),
                     ptsl : append( ptsl, [line_width = lwdef] )
                    )                       
                  else return( doerr("use lw(5) for example " ) ),
               if ctop = add then 
                 for ll thru length(ctargs) do (
                   if ctargs[ll] = grid then mkgrid : true
                   else if ctargs[ll] = xaxis then mkxaxis : true  
                    else if ctargs[ll] = yaxis then mkyaxis : true
                    else if ctargs[ll] = xyaxes then (
                        mkxaxis: true,mkyaxis:true )
                    else 
                      return( doerr("contour: add(grid,xaxis,yaxis,xyaxes) " ) )
                  )             
             
             )
          ),
         
         /* use default line width = 1 unless over-ridden by local lw(n) arg*/
         
         if not nlw then (
             ptsl : cons(line_width = 1,ptsl ),
             ptsl : append(ptsl, [line_width = lwdef] )
            ), 

   /* merge ptsl with ptslist  */            
                
          ptslist : append( ptslist, ptsl )
   
             /* end case contour  */
        ),                    
        
        
        

        
        /************ case para **************************/
        
        /* interface to parametric 
           syntax: para( xofu,yofu,u,umin,umax,lw(n),lc(c),lk(string) )
           example:
              para( 2*cos(u),u^2,u,0,2*%pi , lc(blue), lk("case 1") )
              
           to see this whole curve, need to add xr(-3,3), yr(0,40) to qdraw args
           Naturally, you can use any symbol as the parameter.
        */   
        
        if qtop = para then ( 
           
         /* the first five args are required for passing
             to draw2d's parametric(..)
              */
           
          nargs : length(targs), 
          
          if nargs < 5 then (print("para syntax: para(xofu,yofu,u,u1,u2,lc(c),lw(n),lk(string) ) "),
                  print("first five args are required"),
               return( doerr("only lc(c), lw(n), and lk(string) options can be included"))
               ),
          if nargs > 8 then return( doerr("para: only lc(c), lw(n), and lk(string) options allowed ")),
          /* elist holds five args for parametric */
          
          elist : rest(targs,-(nargs-5) ), 
          
          /* the first arg of elist should not be a list  */
          
          if listp(elist[1]) then
               return( doerr("para: first arg should not be a list")),
          
          /*  the last three args of elist should be [var,var1,var2 ] */
          
            /* first make sure numerical arguments of hlim
               are converted to floating point numbers, especially
               things like [x,-%pi/2,%pi/2]    */
               
          ulim : float( rest(elist,2) ), 
          
           /* check first element of ulim is not a number */
           
           if numberp(ulim[1]) then
            return( doerr("para: ulim=[var,var1,var2]: var is a number" ) ), 
          
                          
           /* check last two elements of ulim are numbers */

          if not numberp(ulim[2]) then
            return( doerr("para: ulim=[var,var1,var2]: var1 is not a number" ) ),
           
          if not numberp(ulim[3]) then
            return( doerr("para: ulim=[var,var1,var2]: var2 is not a number" ) ),
             
          
         
          /* the first five arguments pass to draw2d's parametric function
                */
          
          ptsl : [apply( 'parametric, elist ) ],  
         
          
          
        /* pr is a list of zero, one, two, or three options  */
          
          pr : rest(targs,5),
          lp : length(pr), 

          if lp > 0 then (             
                                           
             if not goodargs(pr,"para options: lc(color), lw(n), lk(string) ",[lc,lw,lk] )
                  then  return() ,
                  
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)          
            ),
            
          
  /* merge ptsl with ptslist  */
                
          ptslist : append( ptslist, ptsl )
          
          /* end case para  */        
        
        ),
        
/***************  case polar  *****************/

/* interface to draw2d's polar(...)

    syntax: polar(roftheta,theta,thetamin,thetamax,lc(c),lw(w),lk(string) ) 
        with th, th1, th2 in radians
    
     the 2d plot has x = r(th)*cos(th),  y = r(th)*sin(th)
     
     example:
       polar( 10/theta,theta,1, 2*%pi,lc(blue), lw(5),lk("hyperbolic spiral") )
       
       */
       
        if qtop = polar then ( 
           
         /* the first four args are required for passing
             to draw2d's polar(..)
              */
           
          nargs : length(targs), 
          
          if nargs < 4 then (print("polar syntax: polar(roftheta,theta,thetamin,thetamax,lc(c),lw(w),lk(string) ) "),
                  print("first four args are required"),
               return( doerr("only lc(c), lw(n), and lk(string) options can be included"))
               ),
          if nargs > 7 then return( doerr("polar: only lc(c), lw(n), and lk(string) options allowed ")),
          /* elist holds four args for polar */
          
          elist : rest(targs,-(nargs-4) ), 
          
          /* the first arg of elist should not be a list  */
          
          if listp(elist[1]) then
               return( doerr("polar: first arg should not be a list")),
          
          /*  the last three args of elist should be [var,var1,var2 ] */
          
            /* first make sure numerical arguments of hlim
               are converted to floating point numbers, especially
               things like [x,-%pi/2,%pi/2]    */
               
          ulim : float( rest(elist,1) ), 
          
           /* check first element of ulim is not a number */
           
           if numberp(ulim[1]) then
            return( doerr("polar: ulim=[var,var1,var2]: var is a number" ) ), 
          
                          
           /* check last two elements of ulim are numbers */

          if not numberp(ulim[2]) then
            return( doerr("polar: ulim=[var,var1,var2]: var1 is not a number" ) ),
           
          if not numberp(ulim[3]) then
            return( doerr("polar: ulim=[var,var1,var2]: var2 is not a number" ) ),
             
          
         
          /* the first four arguments pass to draw2d's polar function
                */
          
          ptsl : [apply( 'polar, elist ) ], 
          
        /* pr is a list of zero, one, two, or three options  */
          
          pr : rest(targs,4), 
          lp : length(pr), 

          if lp > 0 then (             
                                           
             if not goodargs(pr,"polar options: lc(color), lw(n), lk(string) ",[lc,lw,lk] )
                  then  return() ,
                  
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)          
            ),
            
          
  /* merge ptsl with ptslist  */
                
          ptslist : append( ptslist, ptsl )
          
          /* end case polar  */        
        
        ),

               

           
         /***************** case circle *********************/
         
         /* syntax:
              circle( x0,y0,radius, lc(c), lw(n), fill(cc) ),
              args lc, lw, and fill are optional and can be in any order
              */
              
         if qtop = circle then (
        
         /* the first three args must be numbers
           which will be passed to draw2d's ellipse function
           in the order (x0,y0,radius,radius,0, 360)   */
           
          nargs : length(targs), 
          
          if nargs < 3 then return( doerr("circle: at least three args needed")),
          elist : rest(targs,-(nargs-3) ),
          
          pr : rest(targs,3),
          lp : length(pr), 
          
          ptsl : [ ellipse(elist[1],elist[2],elist[3],elist[3],0,360) ], 
          
                             
          /* if any options,include them in ptsl list  */
           /* work through valid text args;
                 if lp = 0 nothing is done here 
                 only draws solid lines;
                 legal options are lc, lw, and fill  */
                 
          if lp > 0 then (             
                                           
             if not goodargs(pr,"circle options: lc(color), lw(n), fill(color) ",[lc,lw,fill] )
                  then  return() ,
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)             

            ),
                           
             if anerr then return(),              
                                                  
            /* merge ptsl with ptslist  */
                
             ptslist : append( ptslist, ptsl )
                
                 /*  end case circle */ 
          

          ),

        /*******************  case ellipse  *****************/
        
        
        /* syntax:
                 ellipse(xc,yc,xsma,ysma,th0,dth, lc(c),lw(n),fill(cc)  ),
               args lc, lw, fill are optional and can be in
               any order   */
        
        if qtop = ellipse then (
        
         /* the first six args must be numbers
           corresponding to 
           (xc,yc,xsa,ysa,th0, dth)   */
           
          nargs : length(targs), 
          
          if nargs < 6 then return( doerr("ellipse: at least six args needed")),
          elist : rest(targs,-(nargs-6) ),
          
          pr : rest(targs,6), 
          lp : length(pr), 
          
          /* the first six arguments pass to draw2d's ellipse function  */
          
           ptsl : [ apply('ellipse,elist) ], 
          
                              
          /* if any options,include them in ptsl list  */
           /* work through valid text args;
                 if lp = 0 nothing is done here 
                 only draws solid lines;
                 legal options are lc, lw, and fill  */
                 
            if lp > 0 then (
               if not goodargs(pr,"ellipse options: lc(color), lw(n), fill(color) ",[lc,lw,fill] )
                  then  return() ,
                 /* we know args are not atoms and are legal */     
             
            setoptions(pr)             
                 
            ),
               
             if anerr then return(),

            /* merge ptsl with ptslist  */
                
           ptslist : append( ptslist, ptsl )
                
                 /*  end case ellipse */ 
           ),                   
               
               
            
           /************ case line  **************/
           /* line calls draw2d's points  */
           /* line syntax:
              line( x1,y1,x2,y2, lc(c), lw(n),lk(string) ),
                args lc, lw, and lk are optional
                and can be in any order after the first
                four numbers */
           
           if qtop = line then (  
           
              
             nargs : length(targs), 
          
             if nargs < 4 then return( doerr("line: at least four args needed")),
             elist : rest(targs,-(nargs-4) ),
             if length(elist) # 4 then return( doerr("line: at least four args needed")),
          
          
          /* the first four arguments pass to draw2d's points function 
            as points( [ [x0,y0],[x1,y1] ] ) */
                               
             ptsl :  [ points([ rest(elist,-2),rest(elist,2)])  ], 
             
              pr : rest(targs,4), 
              lp : length(pr),
              
              
            if lp > 0 then (  
            
               if not goodargs(pr,"line options: lc(color), lw(n), lk(string) ",[lc,lw,lk] )
                  then  return() ,
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)

            ),                 
              

            /* complete case line: 
                we need to turn off points_joined and point_type to their 
                 default values so a later call to pts(..)
                 defaults to unconnected points of type pttdef  */
            
               ptsl :  cons(points_joined=true, ptsl ),
               ptsl :  cons(point_type = -1, ptsl ),
               ptsl : append(ptsl,[points_joined = false,point_type=pttdef] ),
               
                            
            /* merge ptsl with ptslist  */
                
                ptslist : append( ptslist, ptsl )  
                
              /*  end case line  */
           
           ), 
           
           
/*********** case vector *************************************/

/*  syntax: vector([x,y],[dx,dy], ha(thdeg), hb(v), hl(v),ht(t), lw(n), lc(c), lk(string) )
         draws a vector with components [dx,dy] starting at [x,y]. The first two
         list arguments are required, all others are optional and can be entered in
         any order after the first two required arguments.
         The default head angle is 30 deg, change to 45 deg using ha(45) for example.
         The default "head both" value is f for false, use hb(t) to set it to true,
                   and hb(f) to return to false.
         The default "head length" is 0.5, use hl(0.7) to change to 0.7.
         The default "head type" is "nofilled"; use ht(e) for "empty", ht(f) for "filled",
                 and ht(n) to change back to "nofilled".           
         The default line width is 3, use lw(5) to change to 5.
         The default line color is black, use lc(brown) to change to brown.
         The default is no key string. use lk("A1") for example to create a text string for key.
         */
         
      if qtop = vector then ( 
              
         nargs : length(targs), 
          
         if nargs < 2 then return( doerr("vector: at least two args needed")),
         /* elist is a list containing the first two arguments */
         elist : rest(targs,-(nargs-2) ),
         
         /* check first two args to vector are lists */
         
         for jq thru 2 do 
            if not listp(elist[jq]) then
               return(doerr("vector([x,y],[dx,dy],options )") ),
               
         
         ptsl : [ apply( 'vector, elist ) ], 
             
         pr : rest(targs,2), 
         lp : length(pr),
              
         if lp > 0 then (  
            
           if not goodargs(pr,"vector options: lc(color), lw(n), lk(string), 
                 ha(thdeg), hb(v), hl(v), ht(v) ",[lc,lw,lk,ha,hb,hl,ht] )
                  then  return() ,
           /* we know args are not atoms and are legal */  
           /*  modify ptsl if any lw,lc,or lk args */   
             
           setoptions(pr),
           
           /* look for args ha,hb,hl, and ht here*/
           
            for jq thru lp do (
               if anerr then return(), 

               tt : pr[jq], 
               ttop : op(tt),
               ttargs : args(tt),
               
               if ttop = ha then (
               
                  if length(ttargs) #1 then
                     return( doerr("vector: use ha(45) for example " ) ),
                     
                  pl : float( ttargs[1] ),   
                  
                  if not numberp(pl) then
                     return( doerr("vector: use ha(45) for example " ) ),
                                   
                  ptsl :  cons(head_angle = pl, ptsl)                     
                     
                  ),
               
                              
               if ttop = hb then (
               
                  if length(ttargs) #1 then
                     return( doerr("vector: use hb(t) or hb(f) " ) ),
                     
                   pl : ttargs[1],
                     
                   if not inlistp( pl, [t,f] ) then
                       return( doerr("vector: use hb(t) or hb(f) " ) ),
                       
                   if pl = t then ptsl :  cons(head_both = true, ptsl) , 
                   
                   if pl = f then ptsl :  cons(head_both = false, ptsl)
                   ),
                   
                if ttop = hl then (
               
                  if length(ttargs) #1 then
                     return( doerr("vector: use hl(0.7) for example " ) ),
                     
                  pl : float( ttargs[1] ),  
                  
                  if not numberp(pl) then 
                     return( doerr("vector: use hl(0.7) for example " ) ),                
                                   
                  ptsl :  cons(head_length = pl, ptsl)                     
                     
                  ),   
                  
               if ttop = ht then (
               
                  if length(ttargs) #1 then
                     return( doerr("vector: use ht(e), ht(f), or ht(n) " ) ),
                     
                   pl : ttargs[1],
                     
                   if not inlistp( pl, [e,f,n] ) then
                       return( doerr("vector: use ht(e), ht(f), or ht(n) " ) ),
                       
                   if pl = e then ptsl :  cons(head_type = empty, ptsl) , 
                   
                   if pl = f then ptsl :  cons(head_type = filled, ptsl),
                   
                   if pl = n then ptsl :  cons(head_type = nofilled, ptsl)
                   )
                /* end jq do loop search for ha,hb,hl,ht options */  

             )
               /* end if lp > 0 option search */
         ),
         
         /* merge ptsl with ptslist  */
                
                ptslist : append( ptslist, ptsl ) 
         
         
         /*  end case  vector  */
         
      ),
         
         
         
           
/*********** case arrowhead  ********************************/

/*  syntax  arrowhead( x, y, theta-deg, s, lc(c), lw(n) )
              first four args required and must be numbers.
              theta is angle in degrees and the direction
                 the arrowhead is to point relative to the
                 positive x axis, ccw from x axis taken as
                 a positive angle.
              s is the length of the sides of the arrowhead.
              args lc and lw are optional, default will
              be defcolor and lwdef
              The opening half angle is hardwired to be
              phi = 25 deg = 0.44 radians              
            example:
              arrowhead(1,1,45,0.3,lc(red) )
              
              The geometry will look better if the xrange
              is about 1.4 times the yrange.
              
      */
      
         if qtop = arrowhead then (  
           
              
             nargs : length(targs), 
          
             if nargs < 4 then return( doerr("try arrowhead(0,0,45,0.3) for example ")),
             elist : float( rest(targs,-(nargs-4) ) ),
             
             /* all four args must be numbers */
             for jq thru 4 do
                if not numberp(elist[jq]) then
                         return( doerr("arrowhead: first 4 args must be numbers" ) ),                  
             if anerr then return(),
                                       
             phi : 0.44,
             xx : elist[1],
             yy : elist[2],
             /* convert angle to radians here */
             th : float(%pi*elist[3]/180),
             sa : elist[4],
             ax : sa*cos(th - phi),
             ay : sa*sin(th - phi),
     
             bx : sa*cos(th + phi),
             by : sa*sin(th + phi),
             
                               
                               
             ptsl :  [ points([ [ xx - ax, yy - ay ],[ xx, yy ] ] ),
                         points( [ [xx - bx, yy - by ], [xx, yy ] ] )  ], 
             
              pr : rest(targs,4), 
              lp : length(pr),
              
              
            if lp > 0 then (  
            
               if not goodargs(pr,"arrowhead options: lc(color), lw(n)  ",[lc,lw ] )
                  then  return() ,
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)

            ),
              

            /* complete case arrowhead: 
                we need to turn off points_joined and point_type to their 
                 default values so a later call to pts(..)
                 defaults to unconnected points of type pttdef  */
            
               ptsl :  cons(points_joined=true, ptsl ),
               ptsl :  cons(point_type = -1, ptsl ),
               ptsl : append(ptsl,[points_joined = false,point_type=pttdef] ),
               
                            
            /* merge ptsl with ptslist  */
                
                ptslist : append( ptslist, ptsl )  
                
              /*  end case arrowhead  */
           
           ),       
              
              
              
              
              
           /************ case rect **************/
           /* rect syntax:
              rect( x0,y0,x1,y1, lc(c), lw(n), fill(cc)  )  */
           
           if qtop = rect then (   

              /*  use draw2d's rectangle  function  */
              /* qdraw args: can have more than one rect()  */
              
              /* first four args of rect = (x0,y0,x1,y1)  */
              /* optional args: lc(color), lw(n), fill(color)  */
              /* overrides default color = black
                 and default linewidth lwval 
                 and default no fill with interior color  */
              /* ptsl = temp list for one call to rect  */
           
                           
                       
            /* the first four args must be numbers
                    corresponding to 
                              (x0,y0,x1,y1)   */
           
             nargs : length(targs), 
          
             if nargs < 4 then return( doerr("rect: at least four args needed")),
             
             elist : rest(targs,-(nargs-4) ),
             
             if length(elist) # 4 then return( doerr("rect: at least four args needed")),
          
             pr : rest(targs,4), 
             lp : length(pr), 
          
          /* the first four arguments pass to draw2d's rectangle function 
            as rectangle( [x0,y0],[x1,y1] ) */
                               
             ptsl :  [ rectangle( rest(elist,-2),rest(elist,2) )  ], 

              
              /* work through valid text args;
                 if lp = 0 nothing is done here 
                 only draw solid lines;
                 legal options are lc, lw, and fill  */
                 
           if lp > 0 then (     
           
               /* check for valid args  */
           
             if not goodargs(pr,"rect options: lc(color), lw(n), fill(color) ",[lc,lw,fill] )
                  then  return() ,
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)
              
            ),    /* end if lp > 0 */
                                 
           if anerr then return(),                          
         
            /* merge ptsl with ptslist  */
                
           ptslist : append( ptslist, ptsl )
                
                 /*  end case rect */ 
           ),    
           
           
           
           /************ case poly **************/
           
           if qtop = poly then (   
              /*  use draw2d's polygon  function  */
              /* qdraw args: can have more than one poly()  */
              
              /* first arg of poly = [ [x0,y0], [x1,y1],... ] 
                 are vertices of the polygon  */
                 
              /* optional args: lc(color), lw(n), fill(color)  */
              /* overrides default color = black
                 and default linewidth lwval 
                 and no fill with interior color  */
              /* ptsl = temp list for one call to poly  */
           
              /* ptsl : [], */
              
                            
              /* first arg must be list of two element lists  */
              pl : first(targs), 
              
              if not listp(pl) then
                return( doerr("first arg of poly:[ [x0,y0],[x1,y1],...]" ) ),
                
              pl1 : first(pl),
              
              if not listp(pl1) then
                return( doerr("first arg of poly:[ [x0,y0],[x1,y1],...]" ) ),
              
              if length(pl1) # 2 then
                return( doerr("first arg of poly:[ [x0,y0],[x1,y1],...]" ) ),
                
              /* ptsl : append( ptsl, [ polygon(pl) ] ),   */
              ptsl : [ polygon(pl) ],
           
              pr : rest(targs), 
             
              lp : length(pr),
              
              /* work through valid text args;
                 if lp = 0 nothing is done here 
                 only draw solid lines;
                 legal options are lc, lw, and fill  */

           if lp > 0 then (     
           
               /* check for valid args  */
           
             if not goodargs(pr,"poly options: lc(color), lw(n), fill(color) ",[lc,lw,fill] )
                  then  return() ,
             /* we know args are not atoms and are legal */     
             
             setoptions(pr)              

            ),    /* end if lp > 0 */
           
           if anerr then return(),

            /* merge ptsl with ptslist  */
                
           ptslist : append( ptslist, ptsl )
                
              /*  end case poly */ 
           ),    
           
           
                                                      
           /********** case pts *******************/
           
           
     if qtop = pts then (

           
         /* ptsl = temp list for one call to pts  */
           
         /* first arg must be list of points  */
              pl : first(targs),               
                           
              if not listp(pl) then
                  return( doerr("first arg of pts must be a list" ) ),
                  
              if length(pl) = 2 then   /* this is true for both of the illust. cases */
                  if not listp( pl[1] ) then pl : [pl],
                       
               ptsl : [ points(pl) ], 
               
               /* now deal with possible optional args to pts(...)  */
               
               pr : rest(targs),
             
              lp : length(pr),
              
              if lp > 0 then (
              
              /* check for valid args  */
              
               if not goodargs(pr,
                  "pts options: pc(color), ps(size), pk(string), pt(type), pj(lw) ",
                  [pc,ps,pt,pj,pk] )  then  return() ,
                  
             /* we now know all args are not atoms and are legal */                   
              
              for jq thru lp do (
                if anerr then return(), 

               tt : pr[jq], 
               ttop : op(tt),
               ttargs : args(tt),
               
                              
               if ttop = pc then 
                  if length(ttargs)=1 then (
                       ptsl :  cons(color=ttargs[1], ptsl) ,
                       ptsl : append( ptsl, [color = coldef] )
                    )
                  else return( doerr("pts: use pc(blue) for example" ) ),
                  
                  
                if ttop = ps then  
                   if length(ttargs)=1 then ( 
                        ptsl : cons(point_size=ttargs[1], ptsl),
                        ptsl : append( ptsl, [point_size = ptsdef] )
                    )                        
                   else return( doerr("pts: use ps(2) for example " ) ),
                                  
                if ttop = pt then  
                  if length(ttargs)=1 then ( 
                         ptsl : cons(point_type=ttargs[1], ptsl),
                         ptsl : append( ptsl, [point_type = pttdef] )
                    )                       
                  else return( doerr("pts: use pt(3) for example " ) ),
                                
                if ttop = pj then 
                  if length(ttargs)=1 then (
                     if ttargs[1] # lwdef then
                           ptsl :  cons(line_width=ttargs[1], ptsl),
                     ptsl :  cons(points_joined=true, ptsl),
                     ptsl : append( ptsl,[ points_joined = false ] ),
                     if ttargs[1] # lwdef then
                         ptsl : append( ptsl,[line_width = lwdef] )
                    )
                  else return( doerr("pts: use pj(2) for example " ) ),

                 if ttop = pk then 
                   if length(ttargs)=1 then (
                        ptsl : cons(key = ttargs[1], ptsl),
                        ptsl : append(ptsl, [ key = "" ] ) 
                    )                        
                   else return( doerr("pts: use pk(\"case 1\") for example " ) )                   

                 )  /* end do loop */
                 
                 /*  end if lp > 0 then  */                                          
              ),   
              
              if anerr then return(),     

                /* merge ptsl with ptslist  */
                
                ptslist : append( ptslist, ptsl )              
           
           
             /* end case pts  */
           ), 
           
           /*********** case errorbars  *******************/
           
           /**  this is meant to be used together with pts(...), as in
              qdraw( pts( ptl, options), errorbars( ptl, dyl, options ),...),
              where we pass the same list of points (ptl) to both pts and errorbars.
              The list dyl can be a single number (as a list or not a list) in which case
              it represents the same +/- dy value of error bar for all the
              points in ptl. Otherwise, one should have a list of separate
              error estimates ( +/- dy) for each of the supplied list of points
              in the form dyl = [dy1, dy2, ... , dyN], which would supply error bars
              for the ptl = [ [x1,y1],[x2,y2],...,[xN,yN] ] .
              default line width is 1 for the error bars, and
              we suggest use of ps(1) with pts(...) .
              options for errorbars are lw(n) and lc(color)  
              */
              

              
          if qtop = errorbars then ( 
             
             if length(targs) = 1 then
                return( doerr("errorbars(ptl,dyl,options" ) ),
             
             /* first arg must be list of points  */
              ptl : first(targs), 
              
                           
              if not listp(ptl) then
                  return( doerr("first arg of errorbars must be a list of points" ) ),
              le : length(ptl), 
                  
              if le = 2 then   /* this is true for both of the illust. cases */
                  if not listp( ptl[1] ) then ptl : [ptl],
                  
               /* redefine le now that we have a list of lists in all cases */
               le : length(ptl), 
                                    
             dyl : second(targs), 
             
             if not listp(dyl) then dyl : [dyl],                   
                  
             ptsl:[points_joined=true,point_type=-1 ],

              if length(dyl) = 1 then (
                /* construct case pts all have same error bars */ 
                dy : dyl[1], 
                for jq thru length(ptl) do  
                    ptsl : append(ptsl,
                      [points( [ [ptl[jq][1],ptl[jq][2]-dy],[ptl[jq][1],ptl[jq][2]+dy]])])                       
                    
                )
                
               else  (
                 /* construct case separate error bars for each point  */ 
                  
                   if length(dyl) # le then
                      return( doerr("number of errorbars must equal number of points" ) ),
                    for jq thru length(ptl) do 
                    ptsl : append(ptsl,
                      [points( [ [ptl[jq][1],ptl[jq][2]-dyl[jq]],[ptl[jq][1],ptl[jq][2]+dyl[jq] ] ])]) 
                                     
                 ),
                 

              /* look for possible options */
              
              /* default errorbars line width  */
              
              errblw : 1,
              
              if length(targs) > 2 then (
                pr : rest(targs,2), 
                
                if not goodargs(pr, "errorbars options: lc(c), lw(n) ", [lc,lw] )  then  return() ,
                
                /* we now know options are non-atomic and valid */
                                
                lp : length(pr), 
                
                for kk thru lp do (
                  
                  tt : pr[kk],
                  ttop : op(tt),
                  ttargs : args(tt),                 
                  if ttop = lc then (
                    if length(ttargs) # 1 then
                      return( doerr("errorbars: use lc(red) for example" ) ),
                    ptsl : cons( color = ttargs[1], ptsl ),
                    ptsl : append(ptsl, [color = coldef ] )
                    ),
                  if ttop = lw then (
                     if length(ttargs) # 1 then
                        return( doerr("errorbars: use lw(2) for example" ) ),
                     errblw : ttargs[1]
                   )      
                    /* end do loop */
                  )
                        /* end length(targs) > 2 case */
              ),
              
              ptsl : cons( line_width = errblw, ptsl),

                 /* we have now constructed the error bar list ptsl                  
                  end list by returning to pts defaults
                   */
                  
              ptsl : append(ptsl,[points_joined=false,point_type=pttdef,line_width = lwdef] ),
                 
              if anerr then return(),     

                /* merge ptsl with ptslist  */
                
              ptslist : append( ptslist, ptsl )                               
             
             
             
             /* end case errorbars  */
           ),  
           
           
                                
             /************  case pic  *****************/
             /* type  can be eps, jpg, or png  */
             /*  syntax:  pic( type , fname , font(string, size) ) )
                 first two args required, font(..) arg optional 
               example: pic( eps, "case1" ) 
               will generate file case1.eps in folder where
               xmaxima was started up, with default font and fontsize which
               can't be changed unless a ps font has been specified.
               pic( eps, "case1", font("Times-Roman",20) ) will generate 
               case1.eps with ps true type font Times-Roman
               with font size 20.
               */
               
             
          if qtop = pic then ( 
          
             
             if npic then
                     return( doerr("can only be one pic(...) arg to qdraw" ) ),
                     
             npic : true,       
             nargs : length(targs),
             
               if (nargs < 2) or (nargs > 3) then
              return( doerr("pic args: type ,fname , font(string,size);
                        type and fname required, font() optional " ) ),
                        
             pictype : targs[1], 
             
             if not inlistp(pictype,[eps,eps_color,jpg,png]) then
                return( doerr("pic types are eps, eps_color, jpg, and png " ) ),       
                
             if pictype = eps then pictype : eps_color,   
                
             fnamestr : targs[2],
             /* check filename string  */
               
             if not stringp(fnamestr) then
                 return( doerr("pic file name must be in double quotes " ) ),
                 
             /* check for period in string  */ 
              
             fnamelst : charlist(fnamestr),
                 
             for kk thru length(fnamelst) do (
                     if fnamelst[kk] = "." then
                       return( doerr("pic file name string cannot contain a period" ) )
               ),
               
              if anerr then return(),
                   
             /* filename tests passed, supplement piclist  */
              piclist : append(piclist, [terminal = pictype, file_name = fnamestr] ),
              
              if nargs = 3 then (
              tt : targs[3],
              ttop : op(tt),
              if ttop # font then
                 return( doerr("pic 3rd arg: font(string,size) " ) ),
              ttargs : args(tt),
              if length(ttargs) # 2 then
                 return( doerr("pic 3rd arg: font(string,size)" ) ),
                      
              fntstr : ttargs[1], 
                    
                /* check filename string  */
               
              if not stringp(fntstr) then
                 return( doerr("font string must be in double quotes " ) ),
              
              fntsize : ttargs[2], 
              if not integerp(fntsize) then
                 return( doerr("pic: font syntax: size must be a positive integer " ) ), 
                      
                /* complete case font */
               piclist : append(piclist,[font = fntstr, font_size = fntsize] ) 
                   
                /* end if nargs = 3 */
              )
                    
               /* end case pic */
           ),
           
           /***************** case more  ****************/
           
           if qtop = more then morelist : append(morelist, targs)

           
          /* end scan 3 do loop  */  
       ) ,     
       
       if anerr then return(),

        /* if no syntax error, complete drlist */
         
           /* default value nticks=5 will result in jaggies for
                explicit functions which are changing rapidly,
                  increase to nticksdef here  */
          
           drlist : cons( nticks = nticksdef, drlist),        
           
           if mkgrid then drlist : cons( grid = true, drlist ),       
       
           /* draw2d's default value of ip_grid_in is [5,5] with
                some jaggies as a result for implicit plots;
                the larger you make these, the longer it takes
                     for the plot  */
          
           drlist : cons(ip_grid_in = [ipgriddef,ipgriddef], drlist),
           
                  
            /* append more(...) args without review */
           if length(morelist) > 0 then drlist : append(drlist, morelist), 
           
              /*    include ptslist after morelist    */
           
           drlist : append(drlist, ptslist),           
       
           /* for no axes, use cut(all) or cut(xyaxes) or cut(yaxis) or cut(xaxis)  */
           
           if mkxyaxes and mkxaxis then drlist : append(drlist,[xaxis=true,xaxis_width=2] ),
           if mkxyaxes and mkyaxis then drlist : append(drlist,[yaxis=true,yaxis_width=2] ),
           
           /* to remove edge axes use cut(all) or cut(edge) 
              since this removes tick marks, it will also remove
               the grid   */
           if not mkedge then  
              drlist : append(drlist,
                  [xtics = 'none, ytics = 'none,
                  axis_bottom=false,axis_top=false, axis_left=false,
                                          axis_right=false] ),

           
           /* append piclist in case not empty  */
           if length(piclist) > 0 then drlist : append(drlist, piclist ),
           
           if nlabel then drlist : append(drlist,labellist),
           
       
           /* add range list to beginning of drlist */
           
           drlist : append(rnglist,drlist ) ,
           
           /* note: could have used drlist:append(drlist,rnglist) to
               get range info at end of list instead */  
               
 /* debug: 
            print(" end value drlist = ",drlist ),     
  */          

            /* qdraw1 returns the list drlist */
            drlist
    
      )$   /*  end qdraw1  */
      
qdraw([qargs]) := ( apply('qdraw1,qargs),
                      if listp(%%) then apply('draw2d,%%) ) $
      
            
     
/**************** qdensity *************************/

qdensity([qda]) :=
   block( [anerr, drlist,dxx,dyy,fnamelst,fnamestr,
             ii,imatrix,jj,kk, lqda,nxx,nyy,paldef,pra ,prb,pictype,
                  qexpr,tt,ttop,ttargs,xrdx,xx,xx1,xx2,
                  xxlist,xyvals,yy, yy1, yy2, yrdy,yylist ], local(doerr),
   
          /*  write standard form error message  */   
          
       doerr(msg) := (anerr:true,print("...syntax error"),print(msg),false),
     
     /* first go, don't check args */
     
     /* palette default value is sort of blue */
     
     paldef : [1,3,8], 
     
     anerr : false,
     
              
    /*  qda is the list of arguments given to qdensity */   
 
     /* lqda is the number of arguments to qdensity */      
     
     lqda : length(qda), 
     
     if lqda > 5 then 
           return( doerr("qdensity(f(x,y),[x,x1,x2,dx],[y,y1,y2,dy],palette(p),pic(..)),
                             palette and pic are optional" ) ),
     
     /* first three args used for args to draw2d's image(..) */
     
     if lqda < 3 then
            return( doerr("qdensity(f(x,y),[x,x1,x2,dx],[y,y1,y2,dy],palette(p),pic(..)),
                               palette and pic are optional " ) ),
      
     pra : float( rest(qda,-(lqda-3) ) ) , 
     
     qexpr : pra[1], 
     xrdx : pra[2],  
     xx : xrdx[1],
     xx1 :  xrdx[2],
     xx2 : xrdx[3],
     dxx : xrdx[4], 
     
     yrdy : pra[3], 
     yy : yrdy[1],
     yy1 : yrdy[2],
     yy2 : yrdy[3],
     dyy : yrdy[4], 
      
     nxx : floor( (xx2 - xx1)/dxx ),  
     nyy : floor( (yy2 - yy1)/dyy ), 
     
     xxlist : float( makelist( xx1 + dxx*ii,ii,1,nxx ) ), 
     
     yylist : reverse( float( makelist(yy1 + dyy*ii,ii,1,nyy ) ) ) , 
     
     xyvals : float( makelist( subst( yy=yylist[jj],
                makelist( subst( xx = xxlist[ii],qexpr),ii,1,length(xxlist)) ),jj,1,length(yylist) ) ),

     
    
     
     imatrix : apply( 'matrix, xyvals ),     
     drlist : [  image( imatrix, xx1,yy1,xx2,yy2 ) ],
     
     /* look for options  */
     
     if lqda > 3 then (
         prb : rest(qda,3), 
         
         for ii thru length(prb) do (
           tt : prb[ii],
           if atom(tt) then
                return( doerr("qdensity options: palette(args), pic(args) " ) ),
           if anerr then return(),
           ttop : op(tt),
           ttargs : args(tt),
           if ttop = palette then (
               if length(ttargs) = 1 then (
                   if ttargs[1] = gray then paldef : [3,3,3]
                   else if ttargs[1] = color then paldef : [7,5,15]
                   else if ttargs[1] = blue then paldef : [1,3,8]
                   else
                    return( doerr("palette(gray,color,blue,or n1,n2,n3 ) " ) )
                )
                else if length(ttargs) = 3 then paldef : [ttargs[1],ttargs[2],ttargs[3] ]
                else
                  return( doerr("palette(gray,color,blue,or n1,n2,n3 ) " ) )
                )
                
            else if ttop = pic then (
            
              if length( ttargs ) # 2 then              
                   return( doerr("pic(type,flname) requires two args" ) ),
                   
              pictype : ttargs[1], 
           
              if pictype = eps then pictype : eps_color,
                   
              fnamestr : ttargs[2],
             
               /* check filename string  */
               
              if not stringp(fnamestr) then
                 return( doerr("pic file name must be in double quotes " ) ),
                 
              /* check for period in string  */ 
              
              fnamelst : charlist(fnamestr),
                 
              for kk thru length(fnamelst) do (
                     if fnamelst[kk] = "." then
                       return( doerr("pic file name string cannot contain a period" ) )
               ),
               
              if anerr then return(),
                   
             /* filename tests passed, create piclist  */
             
              drlist : append(drlist, [terminal = pictype, file_name = fnamestr] )
             
               
              )
                       
            else
               return( doerr("qdensity options: palette(args), pic(args) " ) )
               /* end do loop */
         ) 
           /*  end if lqda > 3 case */
       
       ),
     
     drlist : cons( palette = paldef, drlist ),
     

     
     apply( 'draw2d, drlist )
     
          
     
   )$  
   
   