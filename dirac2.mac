/************************************************************************
    dirac2.mac is a package of Maxima functions which 
    contains code for high energy physics calculations
    and is part of the Dirac package.
    
    Copyright (C) 2010, 2011,  Edwin L. Woollett  <woollett@charter.net>       
    http://www.csulb.edu/~woollett
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU GENERAL PUBLIC LICENSE, Version 2, June 1991,
    as published by the Free Software Foundation.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details. You should have received a
    copy of the GNU General Public License along with this program.
    If not, see http://www.fsf.org/licensing/.
************************************************************************/

/*  dirac2.mac 
    2-11-11 */
    
    
 /* 
   Nlast initialization.
   
   declare D and Gm to be symmetric.
   
   use Mindex to get a default set of index symbols.
 
   definitions for:
   
   conj
   divout
   div_tb   
   dummyp
   eps4    
   fr_ao2
   gmet
   pullfac
   pfactor
   str_to_int
   take_parts 
   to_half_angle
   to_ao2
   ts
   
   
   
   
    
     
 */
    
    disp("dirac2.mac");
    
  kill(all);
  reset();
  
    
 if not lfreeof (rules, eps4rule1) then apply ('kill, [eps4] )$
    
    
    /* remove all global arrays currently existing */
    
 if length (arrays) > 0 then apply ('remarray, arrays)$
 
 
  load("new-timedate.lisp")$ 

  mydate : apply ('sconcat, rest (charlist (timedate(+7)),-15))$  

 _binfo% : "Maxima 5.23.2"$
   

 
   load ("simplifying-new.lisp")$

   disp ("simplifying-new.lisp"); 
     
  
  
    
 load(dgtrace2);
 
 disp ("dgtrace2.mac");
 
 
 load (dgcon2);
 
 disp ("dgcon2.mac");
 
 load(dgeval2);
 
 disp ("dgeval2.mac");
 
 load (dgmatrix2);
 
 disp ( "dgmatrix2.mac ");
 
 
 /******************************************/
 
   /* str_to_int (string) 6-9-10, see examples below 
       a reminder of some string manipulations
       and called by dummyp  */


str_to_int(sval) := 
   block ([cs,rsum:0,pp,jj ],
     cs : reverse (charlist (sval)),
     for jj thru length (cs) do (
       pp : cint (cs[jj]) - 48,
       rsum : rsum + pp*10^(jj -1)),
       rsum )$


/*

(%i1) display2d:false$
(%i2) sn : string(Q572);
(%o2) "Q572"
(%i3) cs : charlist(sn);
(%o3) ["Q","5","7","2"]
(%i4) sn1 : sremove ("Q",sn);
(%o4) "572"


(%i14) str_to_int ("572");
(%o14) 572
(%i15) str_to_int ("52");
(%o15) 52

(%i2) display2d:false$
(%i3) sremove("N","N20");
(%o3) "20"
(%i4) sremove("N","N20N");
(%o4) "20"
(%i5) sremovefirst ("N","N20N");
(%o5) "20N"

*/
  /*** dummyp   3-25-11  *******************/
  /* dummy summation variables generated by traces of
     gamma5 times other dirac matrices are automatically
     of the form [N1,N2,...] depending on how many are needed.
     We want dummyp (N2345) --> true for example.
     dummyp is used by sum_eps1 in dgeval2.mac. */
     
     

       dummyp(expr) := block ([se,dval:false],
          se : string (expr),
          if first (charlist (se)) = "N" then 
            if integerp (str_to_int (sremovefirst ("N",se))) then dval : true,
          dval)$
          
 /*
           
(%i25) dummyp (N1);
(%o25) true
(%i26) dummyp (N21);
(%o26) true
(%i27) dummyp (n1);
(%o27) false
(%i28) dummyp (n20);
(%o28) false

 */
 
 
 /* complex conjugation for expressions containg %i's and real numbers */

 conj(_e%) := subst (-%i,%i,_e%)$
 
 /***** take_parts  6-24-10  *********/
 

  take_parts (expr,nni,nnf) := 
   block ([rsum:0,jj],
    for jj:nni thru nnf do
     rsum : rsum + part (expr,jj),
    rsum )$
    
 /***************/   
    
 /* div_tb = divide numerator and denominator by same symbol */
 /* transferred from tempalg78.mac 8-6-10  */


div_tb(expr,_x%) :=
  block ([ top,bottom],
    top : num(expr),
    bottom : denom(expr),
    top : expand (top/_x%),
    /* display (top), */
    bottom : expand (bottom/_x%),
    /* display (bottom), */
    top/bottom)$

/* if trigsimp is not working, then use */

ts(e,v) := ratsubst(1,cos(v)^2 + sin(v)^2, e)$

/* convert expression containing an angle a into an equivalent expression
   containing instead the half angle a/2 */
  
   

to_half_angle(expr,a) := 
         (ratsubst (2*sin(a/2)*cos(a/2),sin(a),expr),
             ratsubst (cos(a/2)^2 - sin(a/2)^2,cos(a),%%),
              trigsimp (ratsimp (expand (%%))))$
              
/* to a over 2 calls to_half_angle */
              
to_ao2(expr,aa) := 
 block ([pp,jj,rsum],
   if atom(expr) then return(expr),
   
   if op(expr) = "+" then (
    rsum : 0,
    for jj thru length (expr) do (
      pp : part (expr,jj),
      rsum : rsum + expand (to_half_angle (pp,aa)) ) )
      
   else rsum : expand ( to_half_angle(expr,aa)),
   
   rsum )$
   
/* convert from a/2 trig args to a.
     almost the same as
     ev (expr, trigexpand, halfangles)
     */
   
 fr_ao2(expr,a) := (
        ratsubst (sin(a)/2,cos(a/2)*sin(a/2),expr),
        ratsubst (sqrt ( (1+cos(a))/2 ),cos (a/2),%% ),
        ratsubst (sqrt ( (1-cos(a))/2 ),sin (a/2),%% ),
        rootscontract (%%), trigsimp(%%),
        expand (%%) )$
        
    /* divout (e,a) divides each term of the sum e by a */
 
 divout(expr,_aa%) := 
  block ([jj,_newsum% ],
    _newsum% : 0,
    for jj thru length (expr) do      
      _newsum% : _newsum% + part(expr,jj)/_aa%,
    _newsum% )$
   
   
  /* pullfac(expr,a) pulls out an overall factor of a */
   
   pullfac(eexpr,_n%) :=  _n%*divout (eexpr,_n%)$
   
   
   
 
   
    
   
  /* partial factorization pulls out factor var^pp */
   
 pfactor(expr,var,pp) := block (
           [exprc,cexpr,subexpr,restexpr  ],
             exprc : copy(expr),
            cexpr : coeff(exprc,var,pp),
            /* display (cexpr), */
           subexpr : var^pp*cexpr,
            /* display (subexpr), */
           restexpr : exprc - expand(subexpr),
           subexpr + restexpr )$
           
/*
(%i95) t2a;
(%o95) cos(th)*E^2+E^2+m^2*cos(th)-m^2

(%i109) pfactor (t2a,E,2);
(%o109) (cos(th)+1)*E^2+m^2*cos(th)-m^2
(%i110) pfactor (%,m,2);
(%o110) (cos(th)+1)*E^2+m^2*(cos(th)-1)

(%i111) (pfactor (t2a,E,2), pfactor (%%,m,2));
(%o111) (cos(th)+1)*E^2+m^2*(cos(th)-1)

*/

/***************************************/


 
 
  Nlast : 0$ 

 declare ( [D,Gm], symmetric )$
 
  /* old method, before definition
    of Mindex:   declare ([n1,n2,n3,n4,n5,n6,n7,n8,n9,n10], index); */
 
 
  /* Mindex(..) is defined in dgtrace2.mac and used here */
  
  /* greek symbols, for example, 
  
     Mindex (la,mu,nu,rh,si,ta,al,be,ga,de,ep)$    */
   
 
 /* or numbered indices  
 
     Mindex (n1,n2,n3,n4,n5,n6,n7,n8,n9,n10)$    */
     
 /* or both  */
 
 
   Mindex (n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,la,mu,nu,rh,si,ta,al,be,ga,de,ep)$
 
 Mmass (m,M)$
 
  
 
 array (gmet, fixnum, 3,3)$
    
 fillarray (gmet,
         [1,0,0,0,  0,-1,0,0,  0,0,-1,0,  0,0,0,-1])$
    
 

 declare (eps4,antisymmetric)$
     
 tellsimpafter ( eps4[0,1,2,3], 1 )$
 
  
 /**********************************************/
 /* commands for running 15 test files:
     no need for restart of maxima
     since dirac2 kills all
     and resets all before loading definitions.  */
 
 tt1() := (load(dirac2),batch ("dgtrace2-test.mac",test));
 
 tt2() := (load(dirac2),batch ("dgtrace2_test.mac",test));
 
 tcon() := (load(dirac2),batch ("dgcon2-test.mac",test));
 
 tmcon() := (load(dirac2),batch ("dgmcon-test.mac",test));
 
 teval() := (load(dirac2),batch ("dgeval2-test.mac",test));
 
 tin() := (load(dirac2),batch ("dgintro2-test.mac",test));
 
 tm0() := (load(dirac2),batch ("moller0-test.mac",test));
 
 tm1() := (load(dirac2),batch ("moller1-test.mac",test));
 
 tm2() := (load(dirac2),batch ("moller2-test.mac",test));  

  tb1() := (load(dirac2), batch ("bhabha1-test.mac",test))$
  
  tb2() := (load(dirac2), batch ("bhabha2-test.mac",test))$
  
  tc0() := (load(dirac2), batch ("compton0-test.mac",test))$
  
  tc1() := (load(dirac2), batch ("compton1-test.mac",test))$
  
  tp1() := (load(dirac2), batch ("pair1-test.mac",test))$
  
  tp2() := (load(dirac2), batch ("pair2-test.mac",test))$
  
  tm3() := (load(dirac2),batch ("moller3-test.mac",test));
  
  
  
  
  
  


/* note:  Mscalar displays scalarL   */
  

  Mscalar (c1,c2,c3,c4,c5,c6,c7,c8,c9,c10)$
 
 display (indexL,massL,Nlast )$
 
 
  disp (" reserved program capital letter name use: ")$
  disp (" Chi, Con, D, Eps, G, G(1), G5, G5p, Gam, Gm, Gtr, LI, Nlast, UI, P, S, Sig")$
  disp ("  UU, VP, VV, I2, Z2, CZ2, I4, Z4, CZ4, RZ4, N1,N2,... ")$
  disp (" reserved array names: gmet, eps4 ")$
  display (invar_flag, stu_flag)$
  
  display2d:false$
  
  
  
  
  